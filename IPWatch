#! /usr/bin/python
# doc string
#import pickle
from threading import Thread
import urwid
import curses
import os
import pickle
import time
import logging
from IPython.kernel import KernelManager
from IPython.lib.kernel import find_connection_file
from Queue import Empty
from datetime import datetime
import optparse

palette = [
    ('body','black','light gray', 'standout'),
    ('reverse','light gray','black'),
    ('header','white','dark red', 'bold'),
    ('important','dark blue','light gray',('standout','underline')),
    ('editfc','white', 'dark blue', 'bold'),
    ('editbx','light gray', 'dark blue'),
    ('editcp','black','light gray', 'standout'),
    ('bright','dark gray','light gray', ('bold','standout')),
    ('buttn','black','dark cyan'),
    ('buttnf','white','dark blue','bold'),
    ]
# taken from http://nbviewer.ipython.org/gist/minrk/5672711
def collect_outputs(client, timeout=0.1):
    """flush the IOPub channel for outputs, and construct a dict of output data for each msg_id"""
    all_outputs = {}
    while True:
        try:
            msg = client.get_iopub_msg(timeout=timeout)
        except Empty:
            break
        parent_id = msg['parent_header'].get('msg_id', None)
        # no parent, ignore
        if not parent_id:
            continue
        if parent_id not in all_outputs:
            all_outputs[parent_id] = dict(stdout='', stderr='', display_data=[], pyout=[])
        outputs = all_outputs[parent_id]

        header = msg['header']
        msg_type = header['msg_type']
        content = msg['content']
        if msg_type == 'stream':
            outputs[content['name']] += content['data']
        elif msg_type in ('display_data', 'pyout'):
            outputs[msg_type].append(content)
    return all_outputs
######
class PyWatch():
    def __init__(self, stdscr, options):
        for i in range(7):
            curses.init_pair(i+1, 7, i+1)
        self.stdscr = stdscr
        stdscr.keypad(1)
        self.status = {'connection_file':'NULL', 'last_answer':-999}
        input_windows_height = options.input_lines + 1
        self.input_window = InputWindow(self, curses.newwin(input_windows_height, stdscr.getmaxyx()[1], stdscr.getmaxyx()[0]-input_windows_height, 0), input_windows_height)
        #self.watch = WatchPanel(self.msg, self.set_status, curses.newwin(stdscr.getmaxyx()[0]-input_windows_height, stdscr.getmaxyx()[1], 0,0), options.connection_file)

    def main_loop(self):
        self.watch.main_loop()

    def msg(self, message):
        logging.info(message)
        self.input_window.msg(message)

    def set_status(self, key, value):
        if key in self.status and value==self.status[key]:
            return
        self.status[key] = value
        if key!='last_answer':
            logging.debug('status of %s set to %s', key, value)
        self.input_window.status(self.status['connection_file'], self.status.get('error',''), str(self.status['last_answer']))

class WatchWidget(urwid.Widget):

    _sizing = frozenset(['box'])

    def __init__(self, status_setter=None, connection_file='', async=True, timeout=0.5):
        self.status = {}
        self.status_setter = status_setter
        self.timeout = timeout
        self.km = None
        self.cl = None
        self.kernel_dir = None
        self.connection_file = connection_file
        self.setup_kernel_manager(connection_file)
        # box_size and valid_size both hold size tuple. box_size is the last size the parent asked in the render, and valid_size is the size which 'self.content' was rendered with. Only if they match the widget will paint itself.
        self.box_size = None
        self.valid_size = None
        self.async = async
        if self.async:
            self.update_thread = Thread(target=self.update_loop)
            self.update_thread.setDaemon(True)
        self.content = []

    def set_status(self, key, value, unlogged_keys={'last_answer'}):
        if key in self.status and value==self.status[key]:
            return
        self.status[key] = value
        if key not in unlogged_keys:
            logging.debug('status of %s set to %s', key, value)
        if self.status_setter:
            self.status_setter(key, value)

    def setup_kernel_manager(self, connection_file=None):
        if not connection_file:
            if self.kernel_dir:
                files = [os.path.join(self.kernel_dir,x) for x in os.listdir(self.kernel_dir)]
                stats = {}
                for f in files:
                    stats[f] = os.stat(f)
                max_mtime = max([x.st_mtime for x in stats.values()])
                options = [x for x,y in stats.items() if y.st_mtime==max_mtime]
                if len(options)==1:
                    connection_file = options[0]
            else:
                connection_file = '*'
        connection_file = find_connection_file(connection_file)
        self.set_status('connection_file', connection_file)
        logging.info('connection established to connection_file %s'%connection_file)
        if connection_file:
            self.kernel_dir = os.path.dirname(connection_file)
        self.km = KernelManager(connection_file=connection_file)
        self.km.load_connection_file()
        self.cl = self.km.client()
        self.cl.start_channels()
        self.exe('import pickle')
        self.exe('import urwid')
        self.exe('___top_widget = ___top_widget if "___top_widget" in globals() else urwid.Filler(urwid.Text("Hello, World!", align="center"), valign="middle")')

        self.exe('import IPWatch.watch_lib as wlib')

    def exe(self, s):
        return self.cl.execute(s, silent=True, store_history=False)
        #return self.cl.execute(s, silent=False, store_history=True)

    def refresh(self, timeout=0.5):
        content = []
        asked_size = self.box_size
        pending_request = self.exe('print pickle.dumps(list(___top_widget.render((%d,%d)).content()))'%(asked_size))
        outputs = collect_outputs(self.cl, timeout=timeout)
        got_outputs = bool(outputs)
        fine = False
        for msg_id, output in outputs.items():
            if msg_id==pending_request:
                try:
                    content_raw = output['stdout']
                    try:
                        content = pickle.loads(content_raw)
                        if not isinstance(content, list):
                            content = []
                            self.set_status('error','instructions must be a list')
                        else:
                            fine = True
                    except Exception:
                        content = []
                        self.set_status('error','no pickle')
                except IndexError:
                    raise

            pending_request = None
        if fine:
            self.set_status('error','')
            logging.debug('all is fine')
        if content!=self.content:
            self._invalidate()
        self.content = content
        self.valid_size = asked_size
        return got_outputs

    def update_loop(self):
        last_output = datetime.now()
        logging.debug('update loop started')
        while True:
            got_outputs = self.refresh(timeout=self.timeout)
            if got_outputs:
                last_output = datetime.now()
            self.set_status('last_answer', str(datetime.now()-last_output))
            time.sleep(1)

    def render(self, size, focus=False):
        self.box_size = size
        if self.async and not self.update_thread.is_alive():
            self.update_thread.start()
        logging.debug('rendering...')
        if self.content and self.valid_size == self.box_size:
            try:
                rows = []
                for row_elements in self.content:
                    row_content = ''.join([x[2] for x in row_elements])
                    rows.append(row_content)
                return urwid.TextCanvas(rows, maxcol=size[0])
            except Exception:
                logging.exception('cannot render. content is %s', str(self.content))
                self.set_status('error','cannot paint canvas')
                return urwid.TextCanvas(['e'*size[0]]*size[1], maxcol=size[0])
        else:
            return urwid.TextCanvas(['b'*size[0]]*size[1], maxcol=size[0])


class InputWindow(object):
    def __init__(self, app, window, height):
        self.app = app
        self.window = window
        self.msgs= []
        self.height = height
        self.status_line_elements = ['1', '2', '3']
        self.refresh()
    def status(self, *args):
        self.status_line_elements = args
        self.refresh()

    def create_border(self):
        self.window.refresh()
        self.window.move(0,0)
        self.window.addstr("-"*self.window.getmaxyx()[1])

    def add_status_line(self, y):
        if not self.status_line_elements:
            return
        n_elements = len(self.status_line_elements)
        maxx = self.window.getmaxyx()[1]-1
        interval = maxx / ( n_elements - 1 )
        first_elem = self.status_line_elements[0]
        self.window.move(1,0)
        self.window.addstr(first_elem[:maxx] + ' ')
        for i, elem in enumerate(self.status_line_elements[1:-1]):
            if not elem:
                continue
            self.window.move(y, ((i+1)*interval - len(elem)/2) - 1 )
            self.window.addstr(' ' + elem + ' ')
        last_elem = self.status_line_elements[-1]
        self.window.move(y, maxx - len(last_elem))
        self.window.addstr(' ' + last_elem)
    def refresh(self):
        self.window.clear()
        self.create_border()
        self.add_status_line(1)
        msgs_to_display = self.msgs[-self.height+2:]
        for i, s in enumerate(msgs_to_display):
            self.window.move(i+2,0)
            try:
                self.window.addstr(s[:self.window.getmaxyx()[1]-1])
            except:
                raise Exception('cannot display:', s)
        self.window.refresh()
    def msg(self, new_status):
        self.msgs.append(str(new_status).replace('\n',' '))
        if len(self.msgs)>100:
            self.msgs= self.msgs[-10:]
        self.refresh()

def parse_args():
    parser = optparse.OptionParser(usage='usage: %prog [options]')
    parser.add_option('', '--connection-file', type='str', default='')
    parser.add_option('', '--input-lines', type='int', default='3')
    parser.add_option('', '--log-file', type='str', default='')
    parser.add_option('-v', '--verbose', action='store_true')
    return parser.parse_args()

if __name__ == "__main__":
    options, args = parse_args()
    if options.log_file:
        logging.basicConfig(stream=open(options.log_file,'a'),
                format='%(asctime)s | %(levelname)-5s | IPWatch | %(message)s',
                datefmt='%Y/%m/%d %H:%M:%S',
                level=logging.DEBUG if options.verbose else logging.INFO)
    logging.info('Started')
    screen = urwid.raw_display.Screen()
    #text = urwid.Filler(urwid.Text('abc'))
    watch_widget = WatchWidget(connection_file=options.connection_file)
    main_loop = urwid.MainLoop(watch_widget, palette, screen)
    def refresh(x,y):
        main_loop.set_alarm_in(1, refresh)
    main_loop.set_alarm_in(1, refresh)
    main_loop.run()
